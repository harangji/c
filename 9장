#정렬
-내부정렬 : 메인 (주) 메모리만 활용
-외부정렬 : 디스크 (외부 보조 메모리) 활용

#정렬의 종류
1. 버블 정렬 bubble       }
2. 선택 정렬 selection    } -> O ( n ^ 2 )
3. 삽입 정렬 insertion    }

4. 퀵 정렬   quick        } O ( n log n )


#방식 정리
1. 버블 정렬 : 인접한 두 원소를 비교하여 필요에 따라 교환하는 정렬 알고리즘
5 4 3 2 1
4 3 2 1 5
3 2 1 4 5...

2. 선택 정렬 : 배열에서 최솟값을 선택하여 정렬하는 알고리즘 ( 첫번째 자리부터 차례로 교환 )
5 4 3 2 1
1 4 3 2 5
1 2 3 4 5

3. 삽입 정렬 : 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어 하나씩 요소를 적절한 위치에 삽입하여 정렬하는 알고리즘
 [5, 2, 9, 3, 1]
첫 번째 반복 (두 번째 원소):
2를 선택합니다.
5와 비교하여 2를 삽입할 위치를 찾습니다. 배열: [2, 5, 9, 3, 1]

두 번째 반복 (세 번째 원소):
9를 선택합니다.
5와 비교하여 9를 삽입할 위치를 찾습니다. 배열: [2, 5, 9, 3, 1]

세 번째 반복 (네 번째 원소):
3을 선택합니다.
9와 비교하여 3을 삽입할 위치를 찾습니다. 배열: [2, 5, 3, 9, 1]
5와 비교하여 3을 삽입할 위치를 찾습니다. 배열: [2, 3, 5, 9, 1]
2와 비교하여 3을 삽입할 위치를 찾습니다. 배열: [2, 3, 5, 9, 1]

네 번째 반복 (다섯 번째 원소):
1을 선택합니다.
9와 비교하여 1을 삽입할 위치를 찾습니다. 배열: [2, 3, 5, 1, 9]
5와 비교하여 1을 삽입할 위치를 찾습니다. 배열: [2, 3, 1, 5, 9]
3와 비교하여 1을 삽입할 위치를 찾습니다. 배열: [2, 1, 3, 5, 9]
2와 비교하여 1을 삽입할 위치를 찾습니다. 배열: [1, 2, 3, 5, 9]




4. 퀵 정렬 : 분할 정복(divide and conquer) 방식을 사용하여 배열을 정렬하는 알고리즘

1. 배열에서 하나의 원소를 기준 값으로 선택합니다. 이를 pivot이라고 합니다.
2. pivot을 기준으로 배열을 분할합니다. pivot보다 작은 원소는 pivot의 왼쪽에 위치하고, pivot보다 큰 원소는 pivot의 오른쪽에 위치합니다.
3. 분할된 배열을 재귀적으로 퀵 정렬을 수행합니다. 각 분할된 배열에 대해 위 단계를 반복합니다.
4. 재귀적인 정렬이 끝나면 분할된 배열들이 결합되어 정렬된 배열이 생성됩니다.

퀵 정렬은 분할 단계에서 pivot을 선택하는 방법에 따라 다양한 변형이 있을 수 있습니다. 
일반적으로는 첫 번째 원소, 마지막 원소, 중간 원소 등을 pivot으로 선택합니다. 
pivot을 선택하는 방법에 따라 퀵 정렬의 성능이 달라질 수 있습니다.
많은 정렬 알고리즘 중에서 가장 많이 사용되는 알고리즘 중 하나입니다.

